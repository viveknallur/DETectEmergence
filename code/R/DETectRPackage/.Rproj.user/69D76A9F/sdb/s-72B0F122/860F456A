{
    "contents" : "#' Find the internal:external relationships to monitor\n#' \n#' Takes in a vector of numeric values and returns the change periods of the vector\n#' @param internal a data frame of the internal variable data\n#' @param external a data frame of the external variable data\n#' @return relChoosen, a character vector of the relationships choosen\n#' @export  \nchooseVariables <- function(internal,external){\n  library(glmnet)\n  # Step 1: Check if nearZeroVar\n  internal <- injectNoise(internal)\n  external <- injectNoise(external)\n  relsChosen <- vector(mode=\"character\")\n  # Step 2: Check if variable is random\n  internal <- checkRandomness(internal)\n  external <- checkRandomness(external)\n  if(ncol(internal) > 0 & ncol(external) > 0){\n    internal <- convertDF(internal)\n    external <- convertDF(external)\n    # Step 3: Run the Lasso and choose the relationships\n    if(ncol(internal) > 0 & ncol(external) > 0) {\n      lassoMatrix <- matrix(0, nrow=ncol(internal),ncol=ncol(external))\n      # First internal vs external\n      if(ncol(external) > 1){ # check if there is more than one external to choose from. If not, pick it.\n        XGroup <- getXGroup(external)\n        for(i in 1:ncol(internal)){\n          y <- internal[,i]\n          lassoRun.cv<-cv.glmnet(XGroup,y)\n          lassofit<-glmnet(XGroup,y,alpha=1,nlambda=500)\n          lassopred<-predict(lassofit,XGroup,s=lassoRun.cv$lambda.min)\n          lassocoef<-predict(lassofit,s=lassoRun.cv$lambda.min,type=\"coefficients\")\n          for(j in 1:ncol(external)){\n            theIndex = j + 1;\n            if(lassocoef[theIndex,1] != 0.0){\n              lassoMatrix[i,j] = lassoMatrix[i,j] + 1\n            }\n          }\n        }\n      }else{\n        for(i in 1:ncol(internal)){\n          for(j in 1:ncol(external)){\n            lassoMatrix[i,j] = lassoMatrix[i,j] + 1;\n          }\n        }\n      }\n      # Now do external vs internal\n      if(ncol(internal) > 1){\n        XGroup <- getXGroup(internal)\n        for(i in 1:ncol(external)){\n          y <- external[,i]\n          lassoRun.cv<-cv.glmnet(XGroup,y)\n          lassofit<-glmnet(XGroup,y,alpha=1,nlambda=500)\n          lassopred<-predict(lassofit,XGroup,s=lassoRun.cv$lambda.min)\n          lassocoef<-predict(lassofit,s=lassoRun.cv$lambda.min,type=\"coefficients\")\n          for(j in 1:ncol(internal)){\n            theIndex = j + 1;\n            if(lassocoef[theIndex,1] != 0.0){\n              lassoMatrix[j,i] = lassoMatrix[j,i] + 1\n            }\n          }\n        }\n      }else{\n        for(i in 1:ncol(internal)){\n          for(j in 1:ncol(external)){\n            lassoMatrix[i,j] = lassoMatrix[i,j] + 1;\n          }\n        }\n      }\n      # Final Step is to see what variables were selected both forward and backwards.\n      for(i in 1:ncol(internal)){\n        for(j in 1:ncol(external)){\n          if(lassoMatrix[i,j] == 2){\n            relName = paste(names(internal)[i], names(external)[j], sep = \":\")\n            relsChosen = cbind(relsChosen,relName)\n          }\n        }\n      }\n    }\n  }\n  return(relsChosen)\n}\n\n#' Inject random noise into a vector\n#' \n#' Takes in a vector of numeric values and returns the vector with random noise added to each\n#' @param x a vector of numeric values\n#' @return the vector with noise added\n#' @export\ninjectNoiseVector <- function(x){\n  theNoise = runif(n = length(x), min = -0.05, max = 0.05)\n  newVextor = x + theNoise\n  return(newVextor)\n}\n\n#' Return a random number i.e. error\n#' \n#' @return a random number representing a small error.\n#' @export\nreturnARandom <- function(){\n  theNoise = runif(n = 1, min = -0.05, max = 0.05)\n  return(theNoise)\n}\n\n#' Return a dataframe plus random noise\n#' \n#' @return a random a dataframe plus random noise\n#' @export\ninjectNoise <- function(x){\n  rows <- nrow(x)\n  cols <- ncol(x)\n  theNoise = matrix(runif(cols*rows, min = -0.05, max = 0.05), ncol=cols) \n  noisyX = x + theNoise\n  \n  return(noisyX)\n}\n\n# Returns all columns except the first column in a dataframe\ngetXGroup <- function(x) {\n  XGroup <- x[,1]\n  if(ncol(x) > 1){\n    for(i in 2:ncol(x)){\n      XGroup <- cbind(XGroup,x[,i])\n    }\n  }\n  return (XGroup)\n}\n\n# This function checks whether a vector is composed of just random noise/data\ncheckRandomness <- function(x){\n  colsToRemove <- vector(mode = \"numeric\")\n  for(j in 1:ncol(x)){\n    h <- hist(x[,j], breaks = 50, plot = FALSE)\n    counts <- h$counts\n    chiTest <- chisq.test(counts)\n    if(chiTest$p.value >= 0.05){\n      colsToRemove <- cbind(colsToRemove,j)\n    }\n  }\n  if(length(colsToRemove > 0)){\n    newNames <- names(x)[-colsToRemove]\n    x <- as.data.frame(x[,-colsToRemove])\n    colnames(x) <- newNames\n  }\n  return(x)\n}\n\n# This function is used to standardise the values in a dataframe...ie. return a dataframe\n# where the value in each column has had the mean subtracted and been divided by the \n# standard deviation\nconvertDF <- function(x){\n  converted <- x\n  for (i in 1:ncol(x)){\n    meanX <- mean(x[,i])\n    sdX <- sd(x[,i])\n    x[,i] = (x[,i] - meanX)/sdX\n    converted[,i] = x[,i]\n  }\n  return(converted)\n}",
    "created" : 1453986645607.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3781425414",
    "id" : "860F456A",
    "lastKnownWriteTime" : 1453987008,
    "path" : "~/R/x86_64-pc-linux-gnu-library/3.0/DETectRPackage/R/varSelect.R",
    "project_path" : "R/varSelect.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}