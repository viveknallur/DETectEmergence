{
    "contents" : "#' Find the change periods in a time-series of data\n#' \n#' Takes in a vector of numeric values and returns the change periods of the vector\n#' @param x A vector of numeric values\n#' @return The identified change periods\n#' @export  \nchangeP <- function(xVect) {\n  library(pracma)\n  library(signal)\n  library(ggplot2)\n  xVect <- as.numeric(xVect)\n  lastValVec = as.vector(rep(xVect[length(xVect)],times = 100))\n  firstValVec = as.vector(rep(xVect[1],times = 100))\n  extendX = c(firstValVec,xVect)\n  # Step 1: Pass the raw data through a two sided low pass filter (LPF)\n  bf <- butter(2, 1/30, type=\"low\")\n  filteredX <- filter(bf,extendX)\n  filteredX <- filteredX[100:(length(filteredX))]\n  \n  # Step 2: Perform a Diff on the filtered data\n  diffX <- diff(filteredX)\n  # Step 3: Pass the diff result through a second two sided LPF\n  lastValVec = as.vector(rep(diffX[length(diffX)],times = 100))\n  firstValVec = as.vector(rep(diffX[1],times = 100))\n  diffX = c(firstValVec,diffX)\n  diffX = c(diffX,lastValVec)\n  bf2 <- butter(2, 1/30, type=\"low\")\n  filteredDiffX <- filter(bf2, diffX)\n  filteredDiffX <- filteredDiffX[100:(length(filteredDiffX)-100)]\n  # Step 4: Split data into change ups and change down\n  # Do this by flattening opposite changes to 0 in respective series\n  # Down changes series is inverted to enable peak identification\n  changeUp <- filteredDiffX\n  for(i in 1:length(changeUp)){\n    if(changeUp[i] < 0) changeUp[i] = 0\n  }\n  \n  changeDown <- filteredDiffX\n  for(i in 1:length(changeDown)){\n    if(changeDown[i] > 0) changeDown[i] = 0\n  }\n  changeDown <- changeDown * -1\n  \n  # Step 5: Find a peak threshold\n  m1 <- mean(abs(filteredDiffX))\n  mPeak = m1 * 2;\n\n  # Step 6; Find the peaks in the up changes & down changes\n  peaksUp <- findpeaks(changeUp[1:length(changeUp)], minpeakheight=mPeak )\n  peaksDown <- findpeaks(changeDown[1:length(changeDown)], minpeakheight=mPeak )\n  \n  \n  # Step 7: Now find the periods around the peaks\n  pUps <-periodDec(peaksUp[,2],changeUp,m1*.1)\n  pDowns <- periodDec(peaksDown[,2],changeDown,m1*.1)\n  \n  return(list(\"Ups\" = pUps, \"Downs\"=pDowns));\n}\n\n# This function is used to return the periods, i.e. when the change started and\n# when the change ended around an identified set of peaks (the middle of the change period)\n# x is the peaks location, y is the timeseries of the difference (i.e. the timeseries of changes)\n# m is the point below which the change period is considered over (i.e. a change so small as to be ignored).\nperiodDec <- function(x,y,m) {\n  pUps <- x;\n  changeUp <- y;\n  periodsUp <- matrix(0,1,2)\n  periodsUpStart <- as.vector(x=0,mode=\"numeric\")\n  lastPeakStart = 0;\n  for(i in 1: length(pUps)){\n    \n    if(length(periodsUpStart) > 0){\n      lastPeakStart = periodsUpStart[length(periodsUpStart)];\n    }\n    \n    thisPeak <- pUps[i]\n    #Find the start of the peak\n    j <- thisPeak - 1\n    while(changeUp[j] > m && j > 1){\n      j = j - 1;\n    }\n    \n    theStart = j;\n    \n    if(theStart > lastPeakStart){\n      #Find the end of the peak\n      j <- thisPeak + 1\n      while(changeUp[j] > m && j <= length(changeUp)){\n        j = j + 1;\n      }\n      theEnd = j;\n      if(theStart < 170){\n        theStart = 171\n      }\n      if(theEnd > theStart){\n        periodsUpStart = cbind(periodsUpStart,theStart)\n        theP <- c(theStart, theEnd)\n        periodsUp <- rbind(periodsUp, theP)\n      }\n    }\n  }\n  \n  periodsUp = periodsUp[-1,]\n  \n  return(periodsUp)\n}",
    "created" : 1453986353933.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3954933860",
    "id" : "EA29A9DC",
    "lastKnownWriteTime" : 1453986637,
    "path" : "~/R/x86_64-pc-linux-gnu-library/3.0/DETectRPackage/R/changePeriods.R",
    "project_path" : "R/changePeriods.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}